<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>liboptparse: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">liboptparse
   &#160;<span id="projectnumber">0.3.2-0</span>
   </div>
   <div id="projectbrief">command line option parsing with object-oriented interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>liboptparse version 0.3.2-0</p>
<h1>What is liboptparse?</h1>
<p>liboptparse is a simple library for command line argument parsing. options may be declared in a domain specific language resembling regular expressions.</p>
<h1>Why does liboptparse exist?</h1>
<p>this project may seem to imitate existing tools. that impression would be correct. the purpose of liboptparse is to experiment with C++ while doing something which is (suprisingly) useful in that same language: command-line argument processing. this project is done solely for my educational benefit, as I am new to C++, so all constructive criticism is welcomed.</p>
<h1>Details</h1>
<h2>What is an option?</h2>
<p>options are represented by the option_t struct, which specifies the properties of the option as well as its uniquely identifying name. option_t objects are considered equal if they have equal names. options are identified in two key ways: through the name, which is used internally while defining options to maintain consistency, and externally by the user as the single access point to the results of parsing; and through the handles which appear in unparsed input, such as "--version" or "-V". the user provides handles at the time options are defined; an option's name is either the second argument to option_parser's option member or is deduced from the list of handles. options have four properties: number, assignment, collection, and data type, which are used to express the full range of possible option implementations. a typical boolean option, for instance, might be implemented as </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  parser.option(&quot;--histexpand?&quot;)</div></div><!-- fragment --><p> here the handle is "--histexpand", and the "?" following the name indicates that the option is allowed to appear zero or one time (i.e. it has number ZERO_ONE). this number is the default setting, so the question mark could be left out without changing the meaning. since no name is provided to the option method, the name of this option is deduced to be simply "histexpand".</p>
<p>the following lists enumerate all of the values of the four properties, their meanings, and the syntax used to set them. the parse input is the first argument passed to option_parser's parse member, which has type char **. a handle list is the group of handles separated in the option spec by pipes (|).</p>
<p>Num_Prop:</p><ol type="1">
<li>ZERO_ONE | "?" at the end of the handle list (default) | option may occur zero or one time</li>
<li>ZERO_MANY | "\*" at the end of the handle list | option may occur any number of times</li>
</ol>
<p>Assign_Prop:</p><ol type="1">
<li>NO_ASSIGN | option does not take arguments (default) | no syntax needed</li>
<li>EQ_REQUIRED | option takes argument, but must use an equal sign | "=" after handle list and number modifiers, if any</li>
<li>EQ_MAYBE | option takes arguments, but may use an equals sign or grab the next value in the parse input | "=?"</li>
<li>EQ_NEVER | option takes arguments, but may not use an equals sign | "=!"</li>
<li>STUCK | option takes an argument that is appended to the handle | "=|" (not yet implemented)</li>
</ol>
<p>Collect_Prop:</p><ol type="1">
<li>SCALAR | argument treated as a single value for storage (default) | no syntax needed</li>
<li>LIST | argument treated as comma-separated list, each element of which is stored separately | "[]" following assignment property, if any</li>
</ol>
<p>Data_Type:</p><ol type="1">
<li>STRING | argument is a string (default) | "s" after assignment property or in "[]"</li>
<li>INTEGER | argument must contain only digits | "i" ...</li>
<li>FLOAT | argument must contain only digits or a period surrounded by digits | "f" ...</li>
</ol>
<h2>API</h2>
<p>the library uses the util namespace. functionality is distributed in three classes: option_t, option_parser, option_info. in most cases, option_t need not be used directly. the other two classes are essential to the library and will be discussed here.</p>
<h3>option_parser:</h3>
<p>option_parser is the class used to define all the possible options to your command line application and to initiate parsing. it privately uses a map to store pairs of "handles" and option_t objects, and a set to store the names of option_t objects already registered in the handle map. this set allows the parser to ensure that no equal but incompatible options are registered. see above for clarification of this scenario.</p>
<p><code>std::shared_ptr&lt;option_t&gt; option(std::string spec, std::string name = "")</code></p>
<p>declare an option</p>
<p><code>option_info parse(char** argv, int argc)</code></p>
<p>parse all known options from argc words in argv</p>
<p><code>void clear_options()</code></p>
<p>free memory used to store options </p><h3>option_info:</h3>
<p><code>bool has(std::string name)</code></p>
<p>check whether an option was found</p>
<p><code>int count(std::string name)</code></p>
<p>check the number of occurrences of an option</p>
<p><code>std::string arg(std::string name, std::string default)</code></p>
<p>return the first argument found under option name, or the default</p>
<p><code>IterPair list(std::string name)</code></p>
<p>return iterators denoting range of values stored under option name</p>
<p><code>std::vector&lt;std::string&gt; rest</code></p>
<p>contains the non-option strings from the parsing source</p>
<h2>Dependencies</h2>
<p>liboptparse depends only on the standard library of C++11</p>
<p>building it requires CMake &gt;= 3.0, Make, and a C++ compiler that supports C++11.</p>
<p>all tests depend on libtap++.</p>
<h1>Installation</h1>
<h2>Ubuntu/Debian</h2>
<p>Clone the project and <code>cd</code> to its directory. Run CMake on the current directory: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake .</div></div><!-- fragment --><p>Then use make to build, test, and install: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;make</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;make test</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;sudo make install</div></div><!-- fragment --><p>make's <code>debug</code> target can be used in place of <code>test</code>. it runs uses a shell script as a substitute for CTest, the test driver included with CMake, because CTest does not play well with unit test libraries. invoke ctest manually if you cannot or don't wish to run the script. in that case, for better test output I recommend that you invoke ctest with the <code>--verbose</code> option.</p>
<h2>Windows</h2>
<p>liboptparse doesn't support Windows</p>
<h1>License</h1>
<p>Copyright (C) 2018 Adam Marshall</p>
<p>Made available under the MIT license, which is distributed with the project itself </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
